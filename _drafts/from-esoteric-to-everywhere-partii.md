---
layout: post
title: 'From Esoteric to Everywhere: Running Brainfuck on Billions of Devices'
date: 2025-07-22
lang: pt-BR
category: ['compiladores']
---

in the last article, we discussed brainfuck and implemented a compiler + vm that can run brainfuck code.

continuing the journey to run brainfuck on billions of devices, i will now explore the java virtual machine (jvm). 

To run brainfuck on the JVM, we need to, somehow, translate brainfuck commands into JVM bytecode. There are some ways to do this. One could generate Java source code and the compile it, or use some tool that generates assembly-like code that is then assembled into bytecode.

I decided to take a more direct approach: generating JVM bytecode directly. Generating Java source code would be cheating, and using an assembler would hide some details that i wanted to explore.

To generate bytecode directly, I needed to understand the JVM bytecode format. If this was the first compiler ever
written to the JVM I would have to read through the JVM specification and implementet the bytecode generation. THis
would be a huge pinpoint task, but luckily, there are existing compilers already.

So, to understand how are the building blocks of JVM bytecode, I used the Java compiler (javac) to compile a couple of
Java programs and examined the generated bytecode.

To examine the bytecode, I wrote a simple JavaScript (Node.js) that parses .class files and disassembles them. After
doing this, understanding the `javap` tool output was much easier.

While I will not implmement a full disassembler here, I will discuss the main parts of the class file format and JVM
execution model. Only what's necessary to understand how to generate bytecode for brainfuck.

# The Java Virtual Machine

A Virtual Machine (VM) provides an abstraction layer between the program and the underlying hardware. It allows programs
to run in a platform-independent manner.

It's supposed to emulate a real chip and to do so it has to provide a set of instructions that can be executed, similar
to what we did with our brainfuck VM (remember the **brainfuckCPU** function).

JVM is implemented as a stack-based machine, meaning that it uses a stack to hold intermediate values during
computation. Instructions operate on the stack, pushing and popping values as needed.

But before discussing code execution, let's discuss the structure of a class file and its patterns.

## Class File Structure

To do our probe, let's compile a simple Java program:

```java
// file: Hello.java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

Compiling it with `javac Hello.java` generates a `Hello.class` file. Examining this file with a hex editor shows its
binary structure. Using the `xxd` command, we can see the hexadecimal representation of the file:

```bash
xxd Hello.class

00000000: cafe babe 0000 0044 001d 0a00 0200 0307  .......D........
00000010: 0004 0c00 0500 0601 0010 6a61 7661 2f6c  ..........java/l
00000020: 616e 672f 4f62 6a65 6374 0100 063c 696e  ang/Object...<in
00000030: 6974 3e01 0003 2829 5609 0008 0009 0700  it>...()V.......
00000040: 0a0c 000b 000c 0100 106a 6176 612f 6c61  .........java/la
00000050: 6e67 2f53 7973 7465 6d01 0003 6f75 7401  ng/System...out.
00000060: 0015 4c6a 6176 612f 696f 2f50 7269 6e74  ..Ljava/io/Print
00000070: 5374 7265 616d 3b08 000e 0100 0c48 656c  Stream;......Hel
00000080: 6c6f 2077 6f72 6c64 210a 0010 0011 0700  lo world!.......
00000090: 120c 0013 0014 0100 136a 6176 612f 696f  .........java/io
000000a0: 2f50 7269 6e74 5374 7265 616d 0100 0770  /PrintStream...p
000000b0: 7269 6e74 6c6e 0100 1528 4c6a 6176 612f  rintln...(Ljava/
000000c0: 6c61 6e67 2f53 7472 696e 673b 2956 0700  lang/String;)V..
000000d0: 1601 0005 4865 6c6c 6f01 0004 436f 6465  ....Hello...Code
000000e0: 0100 0f4c 696e 654e 756d 6265 7254 6162  ...LineNumberTab
000000f0: 6c65 0100 046d 6169 6e01 0016 285b 4c6a  le...main...([Lj
00000100: 6176 612f 6c61 6e67 2f53 7472 696e 673b  ava/lang/String;
00000110: 2956 0100 0a53 6f75 7263 6546 696c 6501  )V...SourceFile.
00000120: 000a 4865 6c6c 6f2e 6a61 7661 0021 0015  ..Hello.java.!..
00000130: 0002 0000 0000 0002 0001 0005 0006 0001  ................
00000140: 0017 0000 001d 0001 0001 0000 0005 2ab7  ..............*.
00000150: 0001 b100 0000 0100 1800 0000 0600 0100  ................
00000160: 0000 0100 0900 1900 1a00 0100 1700 0000  ................
00000170: 2500 0200 0100 0000 09b2 0007 120d b600  %...............
00000180: 0fb1 0000 0001 0018 0000 000a 0002 0000  ................
00000190: 0003 0008 0004 0001 001b 0000 0002 001c  ................
```

It shows the binary data in hexadecimal format, which is not human-readable, except for some ASCII strings like `Hello, World!` (which is the string being printed), `java/lang/Object`, `java/io/PrintStream`, etc. You'll understand these later.

This file obeys the Java Class File format specification.

```
ClassFile {
    u4             magic;
    u2             minor_version;
    u2             major_version;
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];
    u2             access_flags;
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    u2             fields_count;
    field_info     fields[fields_count];
    u2             methods_count;
    method_info    methods[methods_count];
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```

To parse this structure, you need to walk through the bytes of the file, reading each field according to its type and
size. The `u1`, `u2`, and `u4` types represent unsigned integers of 1, 2, and 4 bytes, respectively.

```bash
xxd -s0 -l4 Hello.class 
00000000: cafe babe                                  ....

xxd -s4 -l2 Hello.class
00000004: 0000                                      ..

xxd -s6 -l2 Hello.class
00000006: 0044                                      .D

xxd -s8 -l2 Hello.class
00000008: 001d                                      ..
```

From the simple commands above we could extract some important information:

- Magic Number (`0xcafebabe`): identifies the file as a Java class file.
- Minor Version (`0x0000`): minor version of the class file format.
- Major Version (`0x0044`): 68 in decimal, this indicates this class file is compatible with Java 24)
- Constant Pool Count (`0x001d`): Number of entries in the constant pool plus one (29 in decimal, so there are 28 entries).

The constant pool count will be useful to parse the constant pool. That's a thing that happens in binary files, its own values tells you how to parse it.

With this information, you could write a parser that reads the class file byte by byte, extracting each field according to its type and size. I did that, and recommend you to do the same exercise. But it's not necessary. To get details of a class you can use `javap`.

Running `javap -v Hello.class` disassembles the class file and provides a human-readable representation of its contents.
It shows a bunch of information; I will focus on the most relevant parts for our understanding.

### Constant Pool

The constant pool is a table of constants that are referenced by the bytecode instructions. It includes literals (like strings and numbers), class and method references, and other constants used in the class.

```shell
javap -v Hello.class

Constant pool:
   #1 = Methodref          #2.#3          // java/lang/Object."<init>":()V
   #2 = Class              #4             // java/lang/Object
   #3 = NameAndType        #5:#6          // "<init>":()V
   #4 = Utf8               java/lang/Object
   #5 = Utf8               <init>
   #6 = Utf8               ()V
   #7 = Fieldref           #8.#9          // java/lang/System.out:Ljava/io/PrintStream;
   #8 = Class              #10            // java/lang/System
   #9 = NameAndType        #11:#12        // out:Ljava/io/PrintStream;
  #10 = Utf8               java/lang/System
  #11 = Utf8               out
  #12 = Utf8               Ljava/io/PrintStream;
  #13 = String             #14            // Hello world!
  #14 = Utf8               Hello world!
  #15 = Methodref          #16.#17        // java/io/PrintStream.println:(Ljava/lang/String;)V
  #16 = Class              #18            // java/io/PrintStream
  #17 = NameAndType        #19:#20        // println:(Ljava/lang/String;)V
  #18 = Utf8               java/io/PrintStream
  #19 = Utf8               println
  #20 = Utf8               (Ljava/lang/String;)V
  #21 = Class              #22            // Hello
  #22 = Utf8               Hello
  #23 = Utf8               Code
  #24 = Utf8               LineNumberTable
  #25 = Utf8               main
  #26 = Utf8               ([Ljava/lang/String;)V
  #27 = Utf8               SourceFile
  #28 = Utf8               Hello.java
```

### Methods

- <clinit>: static initializer, runs once when the class is loaded
- <init>: constructor, runs when an instance is created
- main: the entry point of the program

#### Code Attribute

#### Field and Method Descriptors

# The Base Structure of a Class File

https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.2

https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.1
https://www.youtube.com/watch?v=LCslqgM48D4&t=1022s
