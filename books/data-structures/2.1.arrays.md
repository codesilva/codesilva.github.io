# Arrays [ORGANIZING]

Olá, sejam bem-vindos a mais uma aula do nosso curso!
Na aula de hoje teremos nossa primeira estrutura, a estrutura fundamental, que vai servir de base para muitas outras.
Hoje falaremos de arrays, estrutura de dados que usamos para lidar com sequências.
Hoje entenderemos seu funcionamento, sua facetas e discutiremos seu funcionamento interno.

## Array Abstract Data Type

O array é essa região contígua de memória que usamos para guardar a nossa sequência de itens.
Você provavelmente já trabalhou com arrays e deve lembrar que em arrays podemos, em geral, fazer as seguintes operações:
- indexação (get_at) - com um índice podemos encontrar um item específico dentro da nossa lista; arrays começam pelo
    índice zero;
- exclusão (delete_at) - quando um item não é mais necessário podemos removê-lo;
- atualização (set_at) - podemos definir o valor que cada índice do array vai conter;
- busca (find) - podemos buscar um item, por seu valor, em um array;

## Arrays Estáticos

A forma mais simples de um array, é um array estático, para começar mais simples vamos começar por ela.
Um array estático encaixa perfeitamente na descrição que vimos durante a definição da ADT.
um array estático vai ser criado a partir da alocação de uma região contígua da memória.
Uma vez definido, suas dimensões não mudam, por isso o estático.
Em C, a definição de um array é tal qual

```c
int main() {
    int primes[4] = {1, 3, 5, 7}

    return 0;
}
```

Esta é a sintaxe em C para definir um array que pode possuir até 4 inteiros.
É legal vermos que isso é de fato uma sequencia contígua de memória. C nos permite fazer isso uma vez que temos acesso
aos endereços das variáveis que estamos utilizando.

Adicionando o seguinte trecho logo após a criação de `primes`:


```c
for(int i=0; i < 4; i++) {
    printf("Index %d is at address: %p\n", &primes[i]);
}
```

esse código printa o endereço de cada posição. Perceba que é os endereços são parecidos variandos os últimos digitos da
esquerda para a direita.

eles vao basicamente incrementando de quatro em quatro. isso acontece porque um inteiro ocupa 4 bytes, logo cada item
vai ocupar um slot de 4 bytes na memoria.

Vejamos agora algumas operacoes com esse array.

#### Indexacao

Uma vez que o array está definido em com dados, é últil que possamos ler informações dessa lista.
As vezes queremos ler de posições específicas, as vezes queremos percorrer inteira, digamos que voce deseja somar os
itens de um array.

Para recuperar/ler um valor de um array, basta que você informe o índice desejado começando de 0 até o tamanho do array
menos 1.

Então, em nosso array de primos temos 4 items. Temos os valores 1, 3, 5, 7 que ficam nos índices, 0, 1,
2 e 3 respectivamente.

```c
printf("Primeiro item do array: %d\n", primes[0]);
printf("Segundo item do array: %d\n", primes[1]);
printf("Terceiro item do array: %d\n", primes[2]);
printf("Quarto item do array: %d\n", primes[3]);
```

#### Definição

No código nós já incializamos o array na criação. Isso não precisa ser feito na verdade. Poderíamos também
telo-inicializado como vazio - algo parecido com vazio

```c
int primes[4];
```

Mas o que queremos ver aqui é como definir item, como por coisas em um array.
Fazemos isso com indexação. Que determina em que lugar o valor desejado será colocado.
Por exemplo, para colocar algo na primeira posição usamos o índice zero, fazendo algo como

```c
primes[0] = 11;
```

Podemos seguir assim até o fim do array

```c
primes[1] = 17;
primes[2] = 19;
primes[3] = 23;
```

#### Exclusao

Exclusoes nao sao possíveis em arrays estáticos.

#### Busca

## Arrays Dinamicos

----

# Arrays [DRAFT]

nota pra mim -> quando for organizar por na seguinte ordem:
    1. o adt de um array estático;
    2. cada operacao em um array estático, mostrando exemplos em C;
    3. ADT de um array dinamico;
    4. passar por cada operacao do array dinamico mostrando exemplos em ruby;

## ADT de um array estático

- get
- set
- delete_at
- search

## ADT de um array dinamico

- get
- set
- delete_at
- search

## Como um array funciona

Olá, sejam bem-vindos a nossa primeira aula realmente vendo as estruturas de dados.
Começaremos hoje pela estrutura fundalmental.
Um array é uma sequência de itens, que é um bloco de memória alocado por aquele processo.
Em essencia, arrays sao estagicos.

na aula anterior vimos como a memória funciona; quando o array é criado, uma região de memória contígua é alocada.
então, aquela regiao é associada a esse array e com isso conseguimos trabalhar nossos itens com indexacao.

[mostra uma regiao de memoria e discorre sobre como a associacao é feita pelos indices, calculando com base no endereco inicial]

Voce provavelmente já trabalhou com arrays em algum momento. Se você trabalha em uma linguagem de mais alto nível como
Ruby, vai ver que os arrays são dinamicos. Diferentes desse que acabamos de ver.

Em ruby voce cria um array

```rb
fruits = Array.new
fruits = []
```

Para esse array não foi definido tamanho e voce nem se preocupa com isso. Ele vai crescendo a medida que for necessário.
Além disso você consegue ter items de diferentes tipos no mesmo array. Isso acontece graças ao runtime do Ruby, nesse
caso, que lida com isso pra você.

### Por debaixo dos panos

Ao inicializar um array eu ruby ou linguagens de mais alto nível, há de fato uma alocação de região contígua de memória.
É definida uma capacidade para aquele array. A medida que itens vao sendo adicionados e a capacidade máxima é atingida
o que acontece é:

1. uma nova região  de memória com capacidade maior é alocada;
2. os itens são transferidos da regiao de memória anterior para a nova
3. libera a regiao de memoria anterior

Para casos em que o array cresce ainda mais, runtimes como NodeJs por exemplo, converte isso internamente em um hashmap.

#### Indexação (get)

Para buscarmos um item em específico usamos o `índice`. Índices, no geral são zero-based devido a forma que calculamos.


```c
#include <stdio.h>
#include <stdlib.h>

int main() {
  int *ptr;
  int size = 5;

  int total_bytes = size * sizeof(int);

  ptr = (int*)malloc(total_bytes);

  printf("%d bytes allocated\n", total_bytes);

  for (int i=0; i < size; i++) {
    printf("O índice %d do array inicia em: %p (aritmetica de ponteiro: %p)\n", i, &ptr[i],&(ptr[i]) + 1);
  }

  free(ptr);

  return 0;
}
```

#### Delete

Deletar um item de um array estático diz respeito a remover o valor de um índice em específico uma vez que não
é possível remover um slot.

Em C, indexamos aquele item que queremos "remover" e setamos como NULL. Essa é uma operação de tempo constante.

#### Search

Buscar em um array é uma operação linear. Em uma lista de frutas, encontrar a fruta pera envolve percorrer o array e ir
checando se o valor desejado já foi encontrado.

Perceba nesse código em C que a partir do início simplesmente calculamos o próximo endereço.

## Array Dinamico

Um array dinamico tem características muito semelhantes com a diferença que ele é dinamico e pode crescer a medida que
items são adicionados. As operações mudam também.

#### Indexação

Funciona normalmente, uma vez definido o array, os itens podem ser indexados normalmente.

#### Search

Também continua igual. 

### Delete

Aqui muda. A exclusao de um item de um array dinamico faz com que todos os items sejam movidos. Se você tem um array de
5 items e remove o primeiro, acontece que todos os outros items da direita serão movidos para a esquerda para preencher
aquele espaço deixado.

Remover é contante, porém mover os itens é linear. Em um array dinamico não temos "buracos deixados" por uma remoção.

## Referencias

https://itnext.io/v8-deep-dives-understanding-array-internals-5b17d7a28ecc - entendendo aspectos internos de array em
javascript
https://embarcados.com.br/ponteiro-em-c-aritmetica-de-ponteiro/
https://gist.github.com/totherik/3a4432f26eea1224ceeb
